<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ethereum Address Report</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    label, input {
      font-size: 1rem;
    }
    #runReportButton {
      font-size: 1rem;
      margin-left: 10px;
      padding: 5px 10px;
      cursor: pointer;
    }
    #results {
      margin-top: 20px;
      border-top: 1px solid #ccc;
      padding-top: 10px;
    }
    pre {
      background: #f5f5f5;
      padding: 10px;
    }
  </style>
</head>
<body>
  <h2>Ethereum Address Balance Report</h2>
  <label for="addressInput">Ethereum Address:</label>
  <input type="text" id="addressInput" size="50" placeholder="0x..." />
  <button id="runReportButton" onclick="runReport()">Run Report</button>

  <div id="results"></div>

  <script>
  
    if (window.location.search !== '') {
        var addr = new URLSearchParams(window.location.search).get('addr');
        
        if (addr !== null) {
            document.getElementById("addressInput").value = addr;
        }
    }
  
    async function runReport() {
      const addressInput = document.getElementById("addressInput");
      const resultsDiv = document.getElementById("results");
      const address = addressInput.value.trim();

      // Basic validation for a hex Ethereum address
      if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
        resultsDiv.innerHTML = "<p>Please enter a valid Ethereum address.</p>";
        return;
      }

      // Clear any previous report
      resultsDiv.innerHTML = "<p>Fetching report, please wait...</p>";

      try {
        const balanceWei = await getEtherBalance(address);
        const balanceEth = parseFloat(balanceWei) / 1e18;
        const validatorData = await getValidatorsFromBeacon(address);
        const validatorBalances = [];
        
        for (const validator of validatorData) {
          const detailedInfo = await getValidatorDetail(validator.validatorindex);
          if (detailedInfo && detailedInfo.status === "active_online") {
            validatorBalances.push({
              index: detailedInfo.validatorindex,
              balance: detailedInfo.effectivebalance,
            });
          }
        }

        let stakedBalance = (validatorBalances.map(vb => vb.balance).reduce((acc, e) => acc + e, 0) / 1e9);

        const nowUtc = new Date();
        const nowUtcIsoString = nowUtc.toISOString(); 
        let resultHtml = `<h2>Balance Snapshot</h2>`;
        resultHtml += `<p><strong>Unstaked Balance:</strong> ${balanceEth.toFixed(16)} ETH</p>`;
                resultHtml += `<li>Data source: ethereum.publicnode.com public JSON-RPC</li>`;
        
          resultHtml += `<p><strong>Staked Balance:</strong> ${stakedBalance.toFixed(16)} ETH</p>`;

          

        if (validatorBalances.length === 0) {
          resultHtml += `<p>No active Beacon Chain validators were found for this address.</p>`;
        } else {
          resultHtml += `<ul>`;
          validatorBalances.forEach((val) => {
            const balEth = (val.balance / 1e9).toFixed(0); // beacon balance is in Gwei
            resultHtml += `<li>Validator ${val.index}: ${balEth} ETH</li>`;
          });
          resultHtml += `</ul>`;
        resultHtml += `<li>Data source: beaconcha.in/api/v1/validator public API</li>`;
        }

        resultHtml += `<h2>Balance Total: ${(stakedBalance + balanceEth).toFixed(16)} ETH</h2>`;
        resultHtml += `<p>Report Generated ${nowUtc.toString()} [${nowUtc.toISOString()}]</p>`;

        resultsDiv.innerHTML = resultHtml;
      } catch (error) {
        console.error(error);
        resultsDiv.innerHTML = `<p style="color:red;">Error fetching data. Check console for details.</p>`;
      }
    }

    /**
     * Get Ether balance from ethereum.publicnode.com (public JSON-RPC).
     * Returns balance in Wei as a decimal string.
     */
    async function getEtherBalance(address) {
      const response = await fetch("https://ethereum.publicnode.com", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "eth_getBalance",
          params: [address, "latest"]
        })
      });
      const data = await response.json();
      // data.result is a hex string; convert to decimal
      return parseInt(data.result, 16).toString();
    }

    /**
     * Retrieves validators that used a specific deposit address
     * from the Beaconcha.in public API.
     */
    async function getValidatorsFromBeacon(address) {
      const url = `https://beaconcha.in/api/v1/validator/eth1/${address}`;
      const response = await fetch(url);
      const data = await response.json();
      // data.data is an array of validator summary objects
      return data.data || [];
    }

    /**
     * Retrieves detailed validator info (including balance).
     */
    async function getValidatorDetail(validatorIndex) {
      const url = `https://beaconcha.in/api/v1/validator/${validatorIndex}`;
      const response = await fetch(url);
      const data = await response.json();
      return data.data || null;
    }
  </script>
</body>
</html>

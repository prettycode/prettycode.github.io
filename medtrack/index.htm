<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#4080ff">
  <link rel="manifest" href="./manifest.json">
  <link rel="icon" type="image/svg+xml" href="./favicon.svg" >
  <title>Medication Tracker</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.2/babel.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback, createContext, useContext, useReducer } = React;

    // Constants
    const STORAGE_KEYS = {
      DOSES: 'medicationDoses',
      INTERVAL: 'medicationInterval'
    };
    
    const INTERVAL_OPTIONS = [
      { label: "3x per Day (Every 8 hours)", value: 8 * 60 },
      { label: "2x per Day (Every 12 hours)", value: 12 * 60 },
      { label: "ED (Every 24 hours)", value: 24 * 60 },
      { label: "EOD (Every 48 hours)", value: 48 * 60 },
      { label: "3x per Week (Every 56 hours)", value: 56 * 60 },
      { label: "2x per Week (Every 84 hours)", value: 84 * 60 },
      { label: "EW (Every 7 days)", value: 168 * 60 }
    ];
    
    const STATUS_COLORS = {
      perfect: 'bg-green-500',
      excellent: 'bg-green-500',
      good: 'bg-blue-500',
      fair: 'bg-yellow-500',
      'needs-improvement': 'bg-red-500'
    };
    
    const ADHERENCE_COLORS = {
      excellent: 'text-green-600',
      good: 'text-blue-600',
      fair: 'text-yellow-600',
      poor: 'text-red-600'
    };

    // Alarm notification when next dose is due
    async function setupNotifications() {
      // Check if notifications are supported
      if (!('Notification' in window)) {
        throw new Error('This browser does not support notifications');
      }
      
      // Request permission
      const permission = await Notification.requestPermission();

      if (permission !== 'granted') {
        throw new Error('Notification permission denied');
      }
      
      // Register service worker
      if (!('serviceWorker' in navigator)) {
        throw new Error('This browser does not support service workers');
      }

      return navigator.serviceWorker.register('service-worker.js');
    }

    var notificationSetup = setupNotifications();

    function triggerAlarmNotification(alarmTitle, alarmBody) {
      notificationSetup.then(() => {
        if (Notification.permission !== 'granted') {
          throw new Error("Can't send notification. Permission has not been granted.");
        }

        // If the app is in the foreground, we can use the Notification API directly
        if (!navigator.serviceWorker.controller) {
          throw new Error("Can't send notification. Service worker is not registered.");
        }

        navigator.serviceWorker.controller.postMessage({
          type: 'ALARM_TRIGGERED',
          title: alarmTitle || 'Notification title',
          body: alarmBody || 'Notification body.',
          icon: 'favicon.svg'
        });
      });
    }

    // Create Context
    const MedicationContext = createContext();

    // Define reducer for state management
    const medicationReducer = (state, action) => {
      switch (action.type) {
        case 'ADD_DOSE':
          return { ...state, doses: [...state.doses, action.payload] };
        case 'UPDATE_DOSE':
          return { 
            ...state, 
            doses: state.doses.map(dose => 
              dose.id === action.payload.id ? { ...dose, time: action.payload.time } : dose
            ).sort((a, b) => new Date(a.time) - new Date(b.time))
          };
        case 'DELETE_DOSE':
          return { ...state, doses: state.doses.filter(dose => dose.id !== action.payload) };
        case 'RESET_DOSES':
          return { ...state, doses: [] };
        case 'SET_INTERVAL':
          return { ...state, intervalMinutes: action.payload };
        case 'SET_NEXT_DOSE':
          return { ...state, nextDoseTime: action.payload };
        default:
          return state;
      }
    };

    // Icon Component
    const Icon = ({ type, size = 24, className = "" }) => {
      const icons = {
        Clock: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>,
        Delete: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="M3 6h18"></path>
          <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
          <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
          <line x1="10" y1="11" x2="10" y2="17"></line>
          <line x1="14" y1="11" x2="14" y2="17"></line>
        </svg>,
        AlertTriangle: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path>
          <path d="M12 9v4"></path>
          <path d="M12 17h.01"></path>
        </svg>,
        Edit: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
          <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
        </svg>
      };
      
      return icons[type] || null;
    };

    // Modal Component
    const Modal = ({ title, children, onClose, actions }) => (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div className="bg-white rounded-lg p-6 w-full max-w-md">
          <h2 className="text-xl font-bold mb-4">{title}</h2>
          {children}
          <div className="flex justify-end space-x-2 mt-4">
            <button
              onClick={onClose}
              className="px-4 py-2 border border-gray-300 rounded text-gray-700 hover:bg-gray-100"
            >
              Cancel
            </button>
            {actions}
          </div>
        </div>
      </div>
    );

    // Card Component
    const Card = ({ title, children, className = "", action }) => (
      <div className={`bg-white p-4 rounded-lg shadow-sm ${className}`}>
        <div className="flex justify-between items-center mb-2">
          <h2 className="text-lg font-semibold">{title}</h2>
          {action}
        </div>
        {children}
      </div>
    );

    // Utility hooks
    const useLocalStorage = (key, initialValue) => {
      const [storedValue, setStoredValue] = useState(() => {
        try {
          const item = localStorage.getItem(key);
          return item ? JSON.parse(item) : initialValue;
        } catch (error) {
          console.error('Error loading from localStorage', error);
          return initialValue;
        }
      });

      const setValue = useCallback((value) => {
        try {
          const valueToStore = value instanceof Function ? value(storedValue) : value;
          setStoredValue(valueToStore);
          localStorage.setItem(key, JSON.stringify(valueToStore));
        } catch (error) {
          console.error('Error saving to localStorage', error);
        }
      }, [key, storedValue]);

      return [storedValue, setValue];
    };

    // Date formatting utilities
    const dateUtils = {
      formatTimeDifference: (milliseconds) => {
        const ms = Math.max(0, milliseconds);
        const days = Math.floor(ms / (1000 * 60 * 60 * 24));
        const hours = Math.floor((ms % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((ms % (1000 * 60)) / 1000);
        
        if (days > 0) return `${days}d ${hours}h ${minutes}m`;
        if (hours > 0) return `${hours}h ${minutes}m ${seconds}s`;
        return `${minutes}m ${seconds}s`;
      },
      
      formatDateTime: (dateString) => {
        const date = new Date(dateString);
        const dayOfWeek = date.toLocaleString(undefined, { weekday: 'long' });
        const month = date.toLocaleString(undefined, { month: 'short' });
        const day = date.getDate();
        const year = date.getFullYear();
        
        let hours = date.getHours();
        const minutes = date.getMinutes().toString().padStart(2, '0');
        const ampm = hours >= 12 ? 'PM' : 'AM';
        
        hours = hours % 12 || 12;
        const timeZone = date.toLocaleString(undefined, { timeZoneName: 'short' }).split(' ').pop();
        
        return `${dayOfWeek}, ${month} ${day}, ${year}, ${hours}:${minutes} ${ampm} ${timeZone}`;
      },
      
      formatDateTimeWithDayOfWeek: (dateString) => {
        const date = new Date(dateString);
        const dayOfWeek = date.toLocaleString(undefined, { weekday: 'long' });
        
        let hours = date.getHours();
        const minutes = date.getMinutes().toString().padStart(2, '0');
        const ampm = hours >= 12 ? 'PM' : 'AM';
        
        hours = hours % 12 || 12;
        const timeOfDay = `${hours}:${minutes} ${ampm}`;
        const timeZone = date.toLocaleString(undefined, { timeZoneName: 'short' }).split(' ').pop();
        
        return { dayOfWeek, timeOfDay, timeZone };
      },
      
      getCurrentDateTimeForInput: () => {
        const now = new Date();
        return new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
      },

      getDateTimeForEditInput: (timeString) => {
        const date = new Date(timeString);
        return new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
      }
    };

    // Provider component
    const MedicationProvider = ({ children }) => {
      const [storedDoses, setStoredDoses] = useLocalStorage(STORAGE_KEYS.DOSES, []);
      const [storedInterval, setStoredInterval] = useLocalStorage(STORAGE_KEYS.INTERVAL, 84 * 60); // Default: 2x per Week
      
      const [state, dispatch] = useReducer(medicationReducer, {
        doses: storedDoses,
        intervalMinutes: storedInterval,
        nextDoseTime: null
      });
      
      const [currentTime, setCurrentTime] = useState(new Date());
      const [showAddModal, setShowAddModal] = useState(false);
      const [showEditModal, setShowEditModal] = useState(false);
      const [editingDose, setEditingDose] = useState(null);
      const [showResetConfirm, setShowResetConfirm] = useState(false);
      const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
      const [deletingDose, setDeletingDose] = useState(null);
      
      // Track if we've already triggered a notification for current dose
      const hasNotifiedRef = useRef(false);
      
      // Calculate next dose time
      const calculateNextDoseTime = useCallback((dosesArray = state.doses) => {
        if (dosesArray.length === 0) {
          dispatch({ type: 'SET_NEXT_DOSE', payload: null });
          return;
        }
        
        const firstDose = new Date(dosesArray[0].time);
        const nextDose = new Date(firstDose.getTime() + (dosesArray.length * state.intervalMinutes * 60 * 1000));
        dispatch({ type: 'SET_NEXT_DOSE', payload: nextDose });
        
        // Reset notification flag when next dose time changes
        hasNotifiedRef.current = false;
      }, [state.doses, state.intervalMinutes]);
      
      // Set up timer for current time and check for notifications
      useEffect(() => {
        const timer = setInterval(() => {
          const now = new Date();
          setCurrentTime(now);
          
          // Check if we need to trigger an alarm notification
          if (state.nextDoseTime && !hasNotifiedRef.current) {
            if (now >= state.nextDoseTime) {
              // Get medication name from next dose
              let alarmTitle = "Medication Due";
              let alarmBody = "Your next dose of medication is due now."
              triggerAlarmNotification(alarmTitle, alarmBody);
              hasNotifiedRef.current = true;
            }
          }
        }, 500);
        
        return () => clearInterval(timer);
      }, [state.nextDoseTime]);
      
      // Save doses to localStorage when they change
      useEffect(() => {
        setStoredDoses(state.doses);
      }, [state.doses, setStoredDoses]);
      
      // Save interval to localStorage when it changes
      useEffect(() => {
        setStoredInterval(state.intervalMinutes);
        if (state.doses.length > 0) calculateNextDoseTime();
      }, [state.intervalMinutes, calculateNextDoseTime, setStoredInterval, state.doses.length]);
      
      // Calculate initial next dose time when component mounts
      useEffect(() => {
        if (state.doses.length > 0) calculateNextDoseTime();
        else dispatch({ type: 'SET_NEXT_DOSE', payload: null });
      }, [calculateNextDoseTime, state.doses.length]);
      
      // Handler functions
      const addDose = useCallback((time) => {
        const newDose = { time: time.toISOString(), id: Date.now() };
        dispatch({ type: 'ADD_DOSE', payload: newDose });
        
        if (state.doses.length === 0) {
          const nextTime = new Date(time.getTime() + state.intervalMinutes * 60 * 1000);
          dispatch({ type: 'SET_NEXT_DOSE', payload: nextTime });
        } else {
          calculateNextDoseTime([...state.doses, newDose]);
        }
        
        // Reset notification flag when a new dose is added
        hasNotifiedRef.current = false;
      }, [state.doses, state.intervalMinutes, calculateNextDoseTime]);
      
      const updateDose = useCallback((id, time) => {
        dispatch({ 
          type: 'UPDATE_DOSE', 
          payload: { id, time: time.toISOString() } 
        });
        // Next dose time will be recalculated via effect that watches doses
        // Reset notification flag when doses are updated
        hasNotifiedRef.current = false;
      }, []);
      
      const deleteDose = useCallback((id) => {
        dispatch({ type: 'DELETE_DOSE', payload: id });
        // Next dose time will be recalculated via effect that watches doses
        // Reset notification flag when doses are deleted
        hasNotifiedRef.current = false;
      }, []);
      
      const resetDoses = useCallback(() => {
        dispatch({ type: 'RESET_DOSES' });
        dispatch({ type: 'SET_NEXT_DOSE', payload: null });
        // Reset notification flag when doses are reset
        hasNotifiedRef.current = false;
      }, []);
      
      const setIntervalMinutes = useCallback((minutes) => {
        dispatch({ type: 'SET_INTERVAL', payload: minutes });
        // Reset notification flag when interval changes
        hasNotifiedRef.current = false;
      }, []);
      
      // Calculate adherence
      const calculateAdherence = useCallback(() => {
        if (state.doses.length === 0) return { percentage: 100, status: 'perfect' };
        
        let totalDeviations = 0;
        const firstDose = new Date(state.doses[0].time);
        
        for (let i = 1; i < state.doses.length; i++) {
          const expectedTime = new Date(firstDose.getTime() + (i * state.intervalMinutes * 60 * 1000));
          const actualTime = new Date(state.doses[i].time);
          const deviation = Math.abs(actualTime - expectedTime) / (1000 * 60);
          
          totalDeviations += deviation;
        }
        
        let totalIntervals = state.doses.length - 1;
        if (state.nextDoseTime) {
          totalIntervals += 1;
          
          const now = currentTime;
          if (now > state.nextDoseTime) {
            const overdueMinutes = (now - state.nextDoseTime) / (1000 * 60);
            totalDeviations += overdueMinutes;
          }
        }
        
        const avgDeviation = totalIntervals > 0 ? totalDeviations / totalIntervals : 0;
        const totalExpectedTime = totalIntervals * state.intervalMinutes;
        
        if (totalExpectedTime === 0) return { percentage: 100, status: 'perfect', avgDeviation: 0 };
        
        const deviationPercentage = (totalDeviations / totalExpectedTime) * 100;
        const percentage = Math.max(0, Math.min(100, 100 - deviationPercentage));
        
        let status = 'perfect';
        if (percentage < 100) {
          if (percentage >= 95) status = 'excellent';
          else if (percentage >= 85) status = 'good';
          else if (percentage >= 70) status = 'fair';
          else status = 'needs-improvement';
        }
        
        return { 
          percentage: Math.round(percentage), 
          status, 
          avgDeviation
        };
      }, [state.doses, state.intervalMinutes, state.nextDoseTime, currentTime]);
      
      // Calculate time until next dose
      const getTimeUntilNextDose = useCallback(() => {
        if (!state.nextDoseTime) return null;
        
        const diff = state.nextDoseTime - currentTime;
        let missedIntervals = 0;
        
        if (diff <= 0) {
          missedIntervals = Math.floor(Math.abs(diff) / (state.intervalMinutes * 60 * 1000));
          return { 
            overdue: true, 
            time: dateUtils.formatTimeDifference(Math.abs(diff)),
            missedIntervals
          };
        }
        
        return { 
          overdue: false, 
          time: dateUtils.formatTimeDifference(diff), 
          missedIntervals: 0 
        };
      }, [state.nextDoseTime, currentTime, state.intervalMinutes]);
      
      // Calculate dose adherence
      const getDoseAdherence = useCallback((doseTime, doseIndex) => {
        const actualTime = new Date(doseTime);
        const firstDose = new Date(state.doses[0].time);
        const expectedTime = new Date(firstDose.getTime() + (doseIndex * state.intervalMinutes * 60 * 1000));
        const diffMinutes = Math.abs(actualTime - expectedTime) / (1000 * 60);
        
        const percentageOfInterval = (diffMinutes / state.intervalMinutes) * 100;
        const roundedPercentage = Math.round(percentageOfInterval);
        const exceedsCap = roundedPercentage > 999;
        
        let category = 'excellent';
        if (roundedPercentage > 50) category = 'poor';
        else if (roundedPercentage > 25) category = 'fair';
        else if (roundedPercentage > 10) category = 'good';
        
        return {
          adherencePercentage: exceedsCap ? 999 : roundedPercentage,
          exceedsCap,
          isEarly: actualTime < expectedTime,
          isLate: actualTime > expectedTime,
          category
        };
      }, [state.doses, state.intervalMinutes]);

      const value = {
        doses: state.doses,
        intervalMinutes: state.intervalMinutes,
        nextDoseTime: state.nextDoseTime,
        currentTime,
        showAddModal,
        setShowAddModal,
        showEditModal,
        setShowEditModal,
        editingDose,
        setEditingDose,
        showResetConfirm,
        setShowResetConfirm,
        showDeleteConfirm,
        setShowDeleteConfirm,
        deletingDose,
        setDeletingDose,
        addDose,
        updateDose,
        deleteDose,
        resetDoses,
        setIntervalMinutes,
        calculateAdherence,
        getTimeUntilNextDose,
        getDoseAdherence,
        dateUtils
      };
      
      return (
        <MedicationContext.Provider value={value}>
          {children}
        </MedicationContext.Provider>
      );
    };

    // Custom hook for medication context
    const useMedication = () => {
      const context = useContext(MedicationContext);
      if (!context) {
        throw new Error('useMedication must be used within a MedicationProvider');
      }
      return context;
    };

    // Modal Components
    const AddDoseModal = () => {
      const { showAddModal, setShowAddModal, addDose, dateUtils } = useMedication();
      const dateTimeInputRef = useRef(null);
      
      if (!showAddModal) return null;
      
      const handleAddDose = () => {
        const selectedDateTimeStr = dateTimeInputRef.current?.value;
        const selectedDateTime = selectedDateTimeStr ? new Date(selectedDateTimeStr) : new Date();
        addDose(selectedDateTime);
        setShowAddModal(false);
      };
      

      // TODO: need multiplier option for scenario where multiple doses are taken at once to catch up.
      // Imagine going on vacation and not taking medication for 3 weeks, then coming back and taking 3 week's worth.

      return (
        <Modal 
          title="Record New Dose"
          onClose={() => setShowAddModal(false)}
          actions={
            <button
              onClick={handleAddDose}
              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              Save
            </button>
          }
        >
          <div>
            <label className="block text-gray-700 mb-2">Date and Time:</label>
            <input
              type="datetime-local"
              className="w-full p-2 border border-gray-300 rounded"
              defaultValue={dateUtils.getCurrentDateTimeForInput()}
              ref={dateTimeInputRef}
            />
          </div>
        </Modal>
      );
    };

    const EditDoseModal = () => {
      const { showEditModal, setShowEditModal, editingDose, setEditingDose, updateDose, dateUtils } = useMedication();
      const editDateTimeInputRef = useRef(null);
      
      if (!showEditModal || !editingDose) return null;
      
      const handleEditDose = () => {
        const selectedDateTimeStr = editDateTimeInputRef.current?.value;
        const selectedDateTime = selectedDateTimeStr ? new Date(selectedDateTimeStr) : new Date();
        updateDose(editingDose.id, selectedDateTime);
        setShowEditModal(false);
        setEditingDose(null);
      };
      
      return (
        <Modal 
          title="Edit Historical Dose"
          onClose={() => {
            setShowEditModal(false);
            setEditingDose(null);
          }}
          actions={
            <button
              onClick={handleEditDose}
              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              Update
            </button>
          }
        >
          <div>
            <label className="block text-gray-700 mb-2">Date and Time:</label>
            <input
              type="datetime-local"
              className="w-full p-2 border border-gray-300 rounded"
              defaultValue={dateUtils.getDateTimeForEditInput(editingDose.time)}
              ref={editDateTimeInputRef}
            />
          </div>
        </Modal>
      );
    };

    const ResetConfirmModal = () => {
      const { showResetConfirm, setShowResetConfirm, resetDoses } = useMedication();
      
      if (!showResetConfirm) return null;
      
      const handleReset = () => {
        resetDoses();
        setShowResetConfirm(false);
      };
      
      return (
        <Modal
          title="Reset Medication History"
          onClose={() => setShowResetConfirm(false)}
          actions={
            <button
              onClick={handleReset}
              className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
            >
              Reset All Data
            </button>
          }
        >
          <p>Are you sure you want to clear all dose history? This cannot be undone.</p>
        </Modal>
      );
    };

    const DeleteDoseConfirmModal = () => {
      const { showDeleteConfirm, setShowDeleteConfirm, deletingDose, setDeletingDose, deleteDose, dateUtils } = useMedication();
      
      if (!showDeleteConfirm || !deletingDose) return null;
      
      const handleDeleteDose = () => {
        deleteDose(deletingDose.id);
        setShowDeleteConfirm(false);
        setDeletingDose(null);
      };
      
      return (
        <Modal
          title="Delete Dose"
          onClose={() => {
            setShowDeleteConfirm(false);
            setDeletingDose(null);
          }}
          actions={
            <button
              onClick={handleDeleteDose}
              className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
            >
              Delete
            </button>
          }
        >
          <p>Are you sure you want to delete this dose from {dateUtils.formatDateTime(deletingDose.time)}?</p>
        </Modal>
      );
    };

    // Component for Frequency selection
    const FrequencySelector = () => {
      const { intervalMinutes, setIntervalMinutes } = useMedication();
      
      return (
        <Card title="Frequency" className="mb-4">
          <select
            value={intervalMinutes}
            onChange={(e) => setIntervalMinutes(parseInt(e.target.value))}
            className="block w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          >
            {INTERVAL_OPTIONS.map((option) => (
              <option key={option.value} value={option.value}>
                {option.label}
              </option>
            ))}
          </select>
        </Card>
      );
    };

    // Component for Next Dose information
    const NextDoseCard = () => {
      const { nextDoseTime, doses, getTimeUntilNextDose, dateUtils } = useMedication();
      const nextDoseInfo = getTimeUntilNextDose();
      
      return (
        <Card title="Next Dose" className="mb-4">
          {nextDoseTime && doses.length > 0 ? (
            <div className="mt-2">
              {(() => {
                const { dayOfWeek, timeOfDay, timeZone } = dateUtils.formatDateTimeWithDayOfWeek(nextDoseTime);

                return (
                  <p className={`flex items-center text-2xl font-bold ${nextDoseInfo.overdue ? 'text-red-500' : 'text-blue-500'}`}>
                    {nextDoseInfo.overdue && <Icon type="AlertTriangle" className="mr-2 text-red-500" />}
                    {!nextDoseInfo.overdue && <Icon type="Clock" className="mr-2" />}
                    {dayOfWeek}, {timeOfDay} {timeZone}
                  </p>
                );
              })()}
              {/* TODO: only apply strong in code below if absolute deviation is >= X && < Y % deviation. */}
              <div className="mt-2 text-gray-700">
                {nextDoseInfo.overdue 
                  ? nextDoseInfo.missedIntervals > 0 
                    ? <><span class="text-red-500"><strong>Overdue</strong></span> by <strong>{nextDoseInfo.time}</strong> (<strong>{nextDoseInfo.missedIntervals + 1}</strong> doses needed)</>
                    : <><span class="text-red-500"><strong>Overdue</strong></span> by <strong>{nextDoseInfo.time}</strong></>
                  : <>Due in <strong>{nextDoseInfo.time}</strong></>
                }
              </div>
            </div>
          ) : (
            <p className="text-gray-500 mt-2">No doses recorded yet. Add your first dose to start tracking.</p>
          )}
        </Card>
      );
    };

    // Component for Adherence information
    const AdherenceCard = () => {
      const { doses, nextDoseTime, currentTime, calculateAdherence } = useMedication();
      
      // Only show adherence if we have more than one dose or if we have one dose and it's overdue
      if (!(doses.length > 1 || (doses.length > 0 && nextDoseTime && currentTime > nextDoseTime))) {
        return null;
      }
      
      const adherence = calculateAdherence();
      
      return (
        <Card title="Adherence" className="mb-4">
          <div className="w-full bg-gray-200 rounded-full h-4">
            <div 
              className={`h-4 rounded-full ${STATUS_COLORS[adherence.status]}`}
              style={{ width: `${adherence.percentage}%` }}
            ></div>
          </div>
          <div className="flex justify-between mt-1">
            <span className="text-sm text-gray-500">0%</span>
            <span className="text-sm font-medium">{adherence.percentage}%</span>
            <span className="text-sm text-gray-500">100%</span>
          </div>
          <p className="text-sm text-gray-600 mt-2">
            Average deviation: {Math.round(adherence.avgDeviation * 10) / 10} minutes
          </p>
        </Card>
      );
    };

    // Component for Dose History
    const DoseHistory = () => {
      const { doses, setShowDeleteConfirm, setDeletingDose, setShowEditModal, setEditingDose, setShowResetConfirm, getDoseAdherence, dateUtils } = useMedication();
      
      return (
        <Card 
          title="History" 
          action={doses.length > 0 && (
            <button 
              onClick={() => setShowResetConfirm(true)} 
              className="text-red-500 text-sm hover:text-red-700"
            >
              <Icon type="Delete" size={16} />
            </button>
          )}
        >
          {doses.length === 0 ? (
            <p className="text-gray-500 mt-2">No history yet</p>
          ) : (
            <ul className="mt-2 divide-y divide-gray-100">
              {[...doses].reverse().map((dose, index) => {
                const reversedIndex = doses.length - 1 - index;
                const isFirstDose = reversedIndex === 0;
                const adherenceInfo = !isFirstDose ? getDoseAdherence(dose.time, reversedIndex) : null;
                
                // Map adherence categories to background colors for the bubble tags
                const adherenceBgColors = {
                  excellent: 'bg-green-100',
                  good: 'bg-blue-100',
                  fair: 'bg-yellow-100',
                  poor: 'bg-red-100'
                };
                
                return (
                  <li key={dose.id} className="py-2 flex items-start">
                    <div className="flex-grow">
                      <div className="flex items-center">
                        <p className="text-gray-700">{dateUtils.formatDateTime(dose.time)}</p>
                        <button 
                          onClick={() => {
                            setEditingDose(dose);
                            setShowEditModal(true);
                          }}
                          className="text-blue-500 hover:text-blue-700 ml-2"
                        >
                          <Icon type="Edit" size={16} />
                        </button>
                      </div>
                      {!isFirstDose && (
                        <div className="mt-1">
                          <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${adherenceBgColors[adherenceInfo.category]} ${ADHERENCE_COLORS[adherenceInfo.category]}`}>
                            {adherenceInfo.exceedsCap ? '> 999' : adherenceInfo.adherencePercentage}% 
                            {' '}{adherenceInfo.isEarly ? 'early' : 'late'}
                          </span>
                        </div>
                      )}
                    </div>
                    <button 
                      onClick={() => {
                        setDeletingDose(dose);
                        setShowDeleteConfirm(true);
                      }}
                      className="text-red-500 hover:text-red-700 ml-4 mt-1"
                    >
                      <Icon type="Delete" size={16} />
                    </button>
                  </li>
                );
              })}
            </ul>
          )}
        </Card>
      );
    };

    // Main Medication Tracker component
    const MedicationTracker = () => {
      const { setShowAddModal } = useMedication();
      const fullYearCreated = 2025;
      
      return (
        <div className="max-w-md mx-auto p-4 bg-gray-50 rounded-lg shadow-md">
          <h1 className="text-2xl font-bold mb-4 text-center">Medication Tracker</h1>
          
          <FrequencySelector />
          <NextDoseCard />
          
          {/* Primary Action Button */}
          <div className="mb-4">
            <button 
              onClick={() => setShowAddModal(true)} 
              className="w-full bg-blue-500 text-white py-3 px-4 rounded-lg font-medium hover:bg-blue-600 transition-colors flex items-center justify-center"
            >
              Record Dose
            </button>
          </div>
          
          <AdherenceCard />
          <DoseHistory />

          <p className="text-xs text-gray-600 mt-3">
              &copy; {fullYearCreated}{new Date().getFullYear() > fullYearCreated ? "â€“" + new Date().getFullYear() : ''} {window.location.host + window.location.pathname}
          </p>

          <AddDoseModal />
          <EditDoseModal />
          <ResetConfirmModal />
          <DeleteDoseConfirmModal />
        </div>
      );
    };

    // Main App component
    const App = () => (
      <div className="min-h-screen bg-gray-100 sm:py-8">
        <MedicationProvider>
          <MedicationTracker />
        </MedicationProvider>
      </div>
    );

    // Render the app
    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#4080ff">
  <link rel="manifest" href="./manifest.json">
  <link rel="icon" type="image/svg+xml" href="./favicon.svg" >
  <title>Medication Tracker</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.2/babel.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback, createContext, useContext, useReducer } = React;

    /**
     * =================================================================
     * APPLICATION CONSTANTS
     * =================================================================
     */
    
    // Storage keys for localStorage
    const STORAGE_KEYS = {
      DOSES: 'medicationDoses',
      INTERVAL: 'medicationInterval'
    };
    
    // Medication interval options
    const INTERVAL_OPTIONS = [
      { label: "3x per Day (Every 8 hours)", value: 8 * 60 },
      { label: "2x per Day (Every 12 hours)", value: 12 * 60 },
      { label: "ED (Every 24 hours)", value: 24 * 60 },
      { label: "EOD (Every 48 hours)", value: 48 * 60 },
      { label: "3x per Week (Every 56 hours)", value: 56 * 60 },
      { label: "2x per Week (Every 84 hours)", value: 84 * 60 },
      { label: "EW (Every 7 days)", value: 168 * 60 }
    ];
    
    // Standardized adherence levels and associated colors
    const ADHERENCE_LEVELS = {
      EXCELLENT: 'excellent',
      FAIR: 'fair',
      POOR: 'poor'
    };
    
    const ADHERENCE_COLORS = {
      [ADHERENCE_LEVELS.EXCELLENT]: 'bg-green-500',
      [ADHERENCE_LEVELS.FAIR]: 'bg-yellow-500',
      [ADHERENCE_LEVELS.POOR]: 'bg-red-500'
    };
    
    const ADHERENCE_TEXT_COLORS = {
      [ADHERENCE_LEVELS.EXCELLENT]: 'text-green-600',
      [ADHERENCE_LEVELS.FAIR]: 'text-yellow-600',
      [ADHERENCE_LEVELS.POOR]: 'text-red-600'
    };
    
    const ADHERENCE_BG_COLORS = {
      [ADHERENCE_LEVELS.EXCELLENT]: 'bg-green-100',
      [ADHERENCE_LEVELS.FAIR]: 'bg-yellow-100',
      [ADHERENCE_LEVELS.POOR]: 'bg-red-100'
    };

    /**
     * =================================================================
     * UTILITY FUNCTIONS
     * =================================================================
     */
    
    // Notification setup and handling
    async function setupNotifications() {
      // Check if notifications are supported
      if (!('Notification' in window)) {
        throw new Error('This browser does not support notifications');
      }
      
      // Request permission
      const permission = await Notification.requestPermission();

      if (permission !== 'granted') {
        throw new Error('Notification permission denied');
      }
      
      // Register service worker
      if (!('serviceWorker' in navigator)) {
        throw new Error('This browser does not support service workers');
      }

      return navigator.serviceWorker.register('service-worker.js');
    }

    const notificationSetup = setupNotifications();

    function triggerAlarmNotification(alarmTitle, alarmBody) {
      notificationSetup.then(() => {
        if (Notification.permission !== 'granted') {
          throw new Error("Can't send notification. Permission has not been granted.");
        }

        if (!navigator.serviceWorker.controller) {
          throw new Error("Can't send notification. Service worker is not registered.");
        }

        navigator.serviceWorker.controller.postMessage({
          type: 'ALARM_TRIGGERED',
          title: alarmTitle ?? 'Notification title',
          body: alarmBody ?? 'Notification body.',
          icon: 'favicon.svg'
        });
      });
    }

    // Date formatting utilities
    const dateUtils = {
      formatTimeDifference: (milliseconds) => {
        const ms = Math.max(0, milliseconds);
        const days = Math.floor(ms / (1000 * 60 * 60 * 24));
        const hours = Math.floor((ms % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((ms % (1000 * 60)) / 1000);
        
        if (days > 0) return `${days}d ${hours}h ${minutes}m`;
        if (hours > 0) return `${hours}h ${minutes}m ${seconds}s`;
        return `${minutes}m ${seconds}s`;
      },
      
      formatDateTime: (dateString) => {
        const date = new Date(dateString);
        const options = {
          weekday: 'long',
          month: 'short',
          day: 'numeric',
          year: 'numeric',
          hour: 'numeric',
          minute: '2-digit',
          hour12: true,
          timeZoneName: 'short'
        };
        
        return date.toLocaleString(undefined, options);
      },
      
      formatDateTimeWithDayOfWeek: (dateString) => {
        const date = new Date(dateString);
        const dayOfWeek = date.toLocaleString(undefined, { weekday: 'long' });
        
        const timeOptions = {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        };
        
        const timeOfDay = date.toLocaleString(undefined, timeOptions);
        const timeZone = date.toLocaleString(undefined, { timeZoneName: 'short' }).split(' ').pop();
        
        return { dayOfWeek, timeOfDay, timeZone };
      },
      
      getCurrentDateTimeForInput: () => {
        const now = new Date();
        return new Date(now.getTime() - now.getTimezoneOffset() * 60000)
          .toISOString()
          .slice(0, 16);
      },

      getDateTimeForEditInput: (timeString) => {
        const date = new Date(timeString);
        return new Date(date.getTime() - date.getTimezoneOffset() * 60000)
          .toISOString()
          .slice(0, 16);
      }
    };

    // Custom hooks
    const useLocalStorage = (key, initialValue) => {
      const [storedValue, setStoredValue] = useState(() => {
        try {
          const item = localStorage.getItem(key);
          return item ? JSON.parse(item) : initialValue;
        } catch (error) {
          console.error('Error loading from localStorage', error);
          return initialValue;
        }
      });

      const setValue = useCallback((value) => {
        try {
          const valueToStore = value instanceof Function ? value(storedValue) : value;
          setStoredValue(valueToStore);
          localStorage.setItem(key, JSON.stringify(valueToStore));
        } catch (error) {
          console.error('Error saving to localStorage', error);
        }
      }, [key, storedValue]);

      return [storedValue, setValue];
    };

    /**
     * =================================================================
     * STATE MANAGEMENT
     * =================================================================
     */
    
    // Create Context
    const MedicationContext = createContext();

    // Define reducer for state management
    const medicationReducer = (state, action) => {
      switch (action.type) {
        case 'ADD_DOSE':
          return { 
            ...state, 
            doses: [...state.doses, action.payload] 
          };
        case 'UPDATE_DOSE':
          return { 
            ...state, 
            doses: state.doses
              .map(dose => dose.id === action.payload.id 
                ? { ...dose, time: action.payload.time } 
                : dose
              )
              .sort((a, b) => new Date(a.time) - new Date(b.time))
          };
        case 'DELETE_DOSE':
          return { 
            ...state, 
            doses: state.doses.filter(dose => dose.id !== action.payload) 
          };
        case 'RESET_DOSES':
          return { 
            ...state, 
            doses: [] 
          };
        case 'SET_INTERVAL':
          return { 
            ...state, 
            intervalMinutes: action.payload 
          };
        case 'SET_NEXT_DOSE':
          return { 
            ...state, 
            nextDoseTime: action.payload 
          };
        default:
          return state;
      }
    };

    /**
     * =================================================================
     * UI COMPONENTS
     * =================================================================
     */
    
    // Icon Component
    const Icon = ({ type, size = 24, className = "" }) => {
      const icons = {
        Clock: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>,
        Delete: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="M3 6h18"></path>
          <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
          <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
          <line x1="10" y1="11" x2="10" y2="17"></line>
          <line x1="14" y1="11" x2="14" y2="17"></line>
        </svg>,
        AlertTriangle: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path>
          <path d="M12 9v4"></path>
          <path d="M12 17h.01"></path>
        </svg>,
        Edit: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
          <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
        </svg>
      };
      
      return icons[type] || null;
    };

    // Modal Component with modern syntax
    const Modal = ({ 
      title, 
      children, 
      onClose, 
      actions 
    }) => (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div className="bg-white rounded-lg p-6 w-full max-w-md">
          <h2 className="text-xl font-bold mb-4">{title}</h2>
          {children}
          <div className="flex justify-end space-x-2 mt-4">
            <button
              onClick={onClose}
              className="px-4 py-2 border border-gray-300 rounded text-gray-700 hover:bg-gray-100"
            >
              Cancel
            </button>
            {actions}
          </div>
        </div>
      </div>
    );

    // Card Component with modern syntax
    const Card = ({ 
      title, 
      children, 
      className = "", 
      action 
    }) => (
      <div className={`bg-white p-4 rounded-lg shadow-sm ${className}`}>
        <div className="flex justify-between items-center mb-2">
          <h2 className="text-lg font-semibold">{title}</h2>
          {action}
        </div>
        {children}
      </div>
    );

    /**
     * =================================================================
     * DATA PROVIDER
     * =================================================================
     */

    // Provider component
    const MedicationProvider = ({ children }) => {
      // Local storage state management
      const [storedDoses, setStoredDoses] = useLocalStorage(STORAGE_KEYS.DOSES, []);
      const [storedInterval, setStoredInterval] = useLocalStorage(STORAGE_KEYS.INTERVAL, 84 * 60); // Default: 2x per Week
      
      // Main application state
      const [state, dispatch] = useReducer(medicationReducer, {
        doses: storedDoses,
        intervalMinutes: storedInterval,
        nextDoseTime: null
      });
      
      // UI state
      const [currentTime, setCurrentTime] = useState(new Date());
      const [showAddModal, setShowAddModal] = useState(false);
      const [showEditModal, setShowEditModal] = useState(false);
      const [editingDose, setEditingDose] = useState(null);
      const [showResetConfirm, setShowResetConfirm] = useState(false);
      const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
      const [deletingDose, setDeletingDose] = useState(null);
      
      // Refs
      const hasNotifiedRef = useRef(false);
      
      // Business logic for dose timing calculations
      const calculateNextDoseTime = useCallback((dosesArray = state.doses) => {
        if (dosesArray.length === 0) {
          dispatch({ 
            type: 'SET_NEXT_DOSE', 
            payload: null 
          });
          return;
        }
        
        const firstDose = new Date(dosesArray[0].time);
        const nextDose = new Date(firstDose.getTime() + (dosesArray.length * state.intervalMinutes * 60 * 1000));
        dispatch({ 
          type: 'SET_NEXT_DOSE', 
          payload: nextDose 
        });
        
        hasNotifiedRef.current = false;
      }, [state.doses, state.intervalMinutes]);
      
      // Time tracking and notification effects
      useEffect(() => {
        const timer = setInterval(() => {
          const now = new Date();
          setCurrentTime(now);
          
          if (!state.nextDoseTime || hasNotifiedRef.current) {
            return;
          }
          
          if (now >= state.nextDoseTime) {
            const { 
              dayOfWeek, 
              timeOfDay, 
              timeZone 
            } = dateUtils.formatDateTimeWithDayOfWeek(state.nextDoseTime);
            
            const alarmTitle = "Medication Due";
            const alarmBody = `Your next dose of medication is due ${dayOfWeek}, ${timeOfDay} ${timeZone}`;
            triggerAlarmNotification(alarmTitle, alarmBody);
            hasNotifiedRef.current = true;
          }
        }, 500);
        
        return () => clearInterval(timer);
      }, [state.nextDoseTime]);
      
      // Syncing state to localStorage
      useEffect(() => {
        setStoredDoses(state.doses);
      }, [state.doses, setStoredDoses]);
      
      useEffect(() => {
        setStoredInterval(state.intervalMinutes);
        if (state.doses.length > 0) {
          calculateNextDoseTime();
        }
      }, [state.intervalMinutes, calculateNextDoseTime, setStoredInterval, state.doses.length]);
      
      // Calculate next dose when doses change
      useEffect(() => {
        if (state.doses.length > 0) {
          calculateNextDoseTime();
        } else {
          dispatch({ 
            type: 'SET_NEXT_DOSE', 
            payload: null 
          });
        }
      }, [calculateNextDoseTime, state.doses.length]);
      
      // Action handlers
      const addDose = useCallback((time) => {
        const newDose = { 
          time: time.toISOString(), 
          id: Date.now() 
        };
        dispatch({ 
          type: 'ADD_DOSE', 
          payload: newDose 
        });
        
        if (state.doses.length === 0) {
          const nextTime = new Date(time.getTime() + state.intervalMinutes * 60 * 1000);
          dispatch({ 
            type: 'SET_NEXT_DOSE', 
            payload: nextTime 
          });
        } else {
          calculateNextDoseTime([...state.doses, newDose]);
        }
        
        hasNotifiedRef.current = false;
      }, [state.doses, state.intervalMinutes, calculateNextDoseTime]);
      
      const updateDose = useCallback((id, time) => {
        dispatch({ 
          type: 'UPDATE_DOSE', 
          payload: { 
            id, 
            time: time.toISOString() 
          } 
        });
        hasNotifiedRef.current = false;
      }, []);
      
      const deleteDose = useCallback((id) => {
        dispatch({ 
          type: 'DELETE_DOSE', 
          payload: id 
        });
        hasNotifiedRef.current = false;
      }, []);
      
      const resetDoses = useCallback(() => {
        dispatch({ 
          type: 'RESET_DOSES' 
        });
        dispatch({ 
          type: 'SET_NEXT_DOSE', 
          payload: null 
        });
        hasNotifiedRef.current = false;
      }, []);
      
      const setIntervalMinutes = useCallback((minutes) => {
        dispatch({ 
          type: 'SET_INTERVAL', 
          payload: minutes 
        });
        hasNotifiedRef.current = false;
      }, []);
      
      // Analysis functions
      const calculateAdherence = useCallback(() => {
        if (state.doses.length === 0) {
          return { 
            percentage: 100, 
            status: ADHERENCE_LEVELS.EXCELLENT 
          };
        }
        
        let totalDeviations = 0;
        const firstDose = new Date(state.doses[0]?.time);
        
        for (let i = 1; i < state.doses.length; i++) {
          const expectedTime = new Date(firstDose.getTime() + (i * state.intervalMinutes * 60 * 1000));
          const actualTime = new Date(state.doses[i]?.time);
          const deviation = Math.abs(actualTime - expectedTime) / (1000 * 60);
          
          totalDeviations += deviation;
        }
        
        let totalIntervals = state.doses.length - 1;
        if (state.nextDoseTime) {
          totalIntervals += 1;
          
          const now = currentTime;
          if (now > state.nextDoseTime) {
            const overdueMinutes = (now - state.nextDoseTime) / (1000 * 60);
            totalDeviations += overdueMinutes;
          }
        }
        
        const avgDeviation = totalIntervals > 0 ? totalDeviations / totalIntervals : 0;
        const totalExpectedTime = totalIntervals * state.intervalMinutes;
        
        if (totalExpectedTime === 0) {
          return { 
            percentage: 100, 
            status: ADHERENCE_LEVELS.EXCELLENT, 
            avgDeviation: 0 
          };
        }
        
        const deviationPercentage = (totalDeviations / totalExpectedTime) * 100;
        const percentage = Math.max(0, Math.min(100, 100 - deviationPercentage));
        
        let status;
        if (percentage >= 95) {
          status = ADHERENCE_LEVELS.EXCELLENT; // Within 5% of target
        } else if (percentage >= 90) {
          status = ADHERENCE_LEVELS.FAIR; // Within 10% of target
        } else {
          status = ADHERENCE_LEVELS.POOR; // Greater than 10% deviation
        }
        
        return { 
          percentage: Math.round(percentage), 
          status, 
          avgDeviation
        };
      }, [state.doses, state.intervalMinutes, state.nextDoseTime, currentTime]);
      
      const getTimeUntilNextDose = useCallback(() => {
        if (!state.nextDoseTime) {
          return null;
        }
        
        const diff = state.nextDoseTime - currentTime;
        let missedIntervals = 0;
        
        if (diff <= 0) {
          missedIntervals = Math.floor(Math.abs(diff) / (state.intervalMinutes * 60 * 1000));
          return { 
            overdue: true, 
            time: dateUtils.formatTimeDifference(Math.abs(diff)),
            missedIntervals
          };
        }
        
        return { 
          overdue: false, 
          time: dateUtils.formatTimeDifference(diff), 
          missedIntervals: 0 
        };
      }, [state.nextDoseTime, currentTime, state.intervalMinutes]);
      
      const getDoseAdherence = useCallback((doseTime, doseIndex) => {
        const actualTime = new Date(doseTime);
        const firstDose = new Date(state.doses[0]?.time);
        const expectedTime = new Date(firstDose.getTime() + (doseIndex * state.intervalMinutes * 60 * 1000));
        const diffMinutes = Math.abs(actualTime - expectedTime) / (1000 * 60);
        
        const percentageOfInterval = (diffMinutes / state.intervalMinutes) * 100;
        const roundedPercentage = Math.round(percentageOfInterval);
        const exceedsCap = roundedPercentage > 999;
        
        let category;
        if (roundedPercentage <= 5) {
          category = ADHERENCE_LEVELS.EXCELLENT; // Within 5% of target
        } else if (roundedPercentage <= 10) {
          category = ADHERENCE_LEVELS.FAIR; // Within 10% of target
        } else {
          category = ADHERENCE_LEVELS.POOR; // Greater than 10% deviation
        }
        
        return {
          adherencePercentage: exceedsCap ? 999 : roundedPercentage,
          exceedsCap,
          isEarly: actualTime < expectedTime,
          isLate: actualTime > expectedTime,
          category
        };
      }, [state.doses, state.intervalMinutes]);

      const calculateStreak = useCallback(() => {
        if (state.doses.length <= 1) {
          return 0;
        }
        
        let currentStreak = 0;
        const firstDose = new Date(state.doses[0]?.time);
        
        // Start from the most recent dose and go backwards
        for (let i = state.doses.length - 1; i > 0; i--) {
          const expectedTime = new Date(firstDose.getTime() + (i * state.intervalMinutes * 60 * 1000));
          const actualTime = new Date(state.doses[i]?.time);
          const diffMinutes = Math.abs(actualTime - expectedTime) / (1000 * 60);
          
          const percentageOfInterval = (diffMinutes / state.intervalMinutes) * 100;
          const isExcellent = percentageOfInterval <= 5; // Same threshold as ADHERENCE_LEVELS.EXCELLENT
          
          if (isExcellent) {
            currentStreak++;
          } else {
            break;
          }
        }
        
        // Check if next dose breaks streak
        if (state.nextDoseTime && currentTime > state.nextDoseTime) {
          const overdueMinutes = (currentTime - state.nextDoseTime) / (1000 * 60);
          const overduePercentage = (overdueMinutes / state.intervalMinutes) * 100;
          
          // Reset streak if significantly overdue
          return overduePercentage > 5 ? 0 : currentStreak;
        }
        
        return currentStreak;
      }, [state.doses, state.intervalMinutes, state.nextDoseTime, currentTime]);

      // Create context value
      const value = {
        doses: state.doses,
        intervalMinutes: state.intervalMinutes,
        nextDoseTime: state.nextDoseTime,
        currentTime,
        showAddModal,
        setShowAddModal,
        showEditModal,
        setShowEditModal,
        editingDose,
        setEditingDose,
        showResetConfirm,
        setShowResetConfirm,
        showDeleteConfirm,
        setShowDeleteConfirm,
        deletingDose,
        setDeletingDose,
        addDose,
        updateDose,
        deleteDose,
        resetDoses,
        setIntervalMinutes,
        calculateAdherence,
        getTimeUntilNextDose,
        getDoseAdherence,
        calculateStreak,
        dateUtils
      };
      
      return (
        <MedicationContext.Provider value={value}>
          {children}
        </MedicationContext.Provider>
      );
    };

    // Custom hook for medication context
    const useMedication = () => {
      const context = useContext(MedicationContext);
      if (!context) {
        throw new Error('useMedication must be used within a MedicationProvider');
      }
      return context;
    };

    /**
     * =================================================================
     * MODAL COMPONENTS
     * =================================================================
     */

    // Modal Components
    const AddDoseModal = () => {
      const { 
        showAddModal, 
        setShowAddModal, 
        addDose, 
        dateUtils 
      } = useMedication();
      const dateTimeInputRef = useRef(null);
      
      if (!showAddModal) {
        return null;
      }
      
      const handleAddDose = () => {
        const selectedDateTime = new Date(dateTimeInputRef.current?.value ?? Date.now());
        addDose(selectedDateTime);
        setShowAddModal(false);
      };
      
      return (
        <Modal 
          title="Record New Dose"
          onClose={() => setShowAddModal(false)}
          actions={
            <button
              onClick={handleAddDose}
              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              Save
            </button>
          }
        >
          <div>
            <label className="block text-gray-700 mb-2">Date and Time:</label>
            <input
              type="datetime-local"
              className="w-full p-2 border border-gray-300 rounded"
              defaultValue={dateUtils.getCurrentDateTimeForInput()}
              ref={dateTimeInputRef}
            />
          </div>
        </Modal>
      );
    };

    const EditDoseModal = () => {
      const { 
        showEditModal, 
        setShowEditModal, 
        editingDose, 
        setEditingDose, 
        updateDose, 
        dateUtils 
      } = useMedication();
      const editDateTimeInputRef = useRef(null);
      
      if (!showEditModal || !editingDose) {
        return null;
      }
      
      const handleEditDose = () => {
        const selectedDateTime = new Date(editDateTimeInputRef.current?.value ?? editingDose.time);
        updateDose(editingDose.id, selectedDateTime);
        setShowEditModal(false);
        setEditingDose(null);
      };
      
      return (
        <Modal 
          title="Edit Historical Dose"
          onClose={() => {
            setShowEditModal(false);
            setEditingDose(null);
          }}
          actions={
            <button
              onClick={handleEditDose}
              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              Update
            </button>
          }
        >
          <div>
            <label className="block text-gray-700 mb-2">Date and Time:</label>
            <input
              type="datetime-local"
              className="w-full p-2 border border-gray-300 rounded"
              defaultValue={dateUtils.getDateTimeForEditInput(editingDose.time)}
              ref={editDateTimeInputRef}
            />
          </div>
        </Modal>
      );
    };

    const ResetConfirmModal = () => {
      const { 
        showResetConfirm, 
        setShowResetConfirm, 
        resetDoses 
      } = useMedication();
      
      if (!showResetConfirm) {
        return null;
      }
      
      const handleReset = () => {
        resetDoses();
        setShowResetConfirm(false);
      };
      
      return (
        <Modal
          title="Reset Medication History"
          onClose={() => setShowResetConfirm(false)}
          actions={
            <button
              onClick={handleReset}
              className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
            >
              Reset All Data
            </button>
          }
        >
          <p>Are you sure you want to clear all dose history? This cannot be undone.</p>
        </Modal>
      );
    };

    const DeleteDoseConfirmModal = () => {
      const { 
        showDeleteConfirm, 
        setShowDeleteConfirm, 
        deletingDose, 
        setDeletingDose, 
        deleteDose, 
        dateUtils 
      } = useMedication();
      
      if (!showDeleteConfirm || !deletingDose) {
        return null;
      }
      
      const handleDeleteDose = () => {
        deleteDose(deletingDose.id);
        setShowDeleteConfirm(false);
        setDeletingDose(null);
      };
      
      return (
        <Modal
          title="Delete Dose"
          onClose={() => {
            setShowDeleteConfirm(false);
            setDeletingDose(null);
          }}
          actions={
            <button
              onClick={handleDeleteDose}
              className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
            >
              Delete
            </button>
          }
        >
          <p>Are you sure you want to delete this dose from {dateUtils.formatDateTime(deletingDose.time)}?</p>
        </Modal>
      );
    };

    /**
     * =================================================================
     * FEATURE COMPONENTS
     * =================================================================
     */

    // Component for Frequency selection
    const FrequencySelector = () => {
      const { 
        intervalMinutes, 
        setIntervalMinutes 
      } = useMedication();
      
      return (
        <Card title="Frequency" className="mb-4">
          <select
            value={intervalMinutes}
            onChange={(e) => setIntervalMinutes(parseInt(e.target.value))}
            className="block w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          >
            {INTERVAL_OPTIONS.map((option) => (
              <option key={option.value} value={option.value}>
                {option.label}
              </option>
            ))}
          </select>
        </Card>
      );
    };

    // Component for Next Dose information
    const NextDoseCard = () => {
      const { 
        nextDoseTime, 
        doses, 
        getTimeUntilNextDose, 
        dateUtils 
      } = useMedication();
      const nextDoseInfo = getTimeUntilNextDose();
      
      if (!nextDoseTime || !doses.length) {
        return (
          <Card title="Next Dose" className="mb-4">
            <p className="text-gray-500 mt-2">No doses recorded yet. Add your first dose to start tracking.</p>
          </Card>
        );
      }
      
      const { 
        dayOfWeek, 
        timeOfDay, 
        timeZone 
      } = dateUtils.formatDateTimeWithDayOfWeek(nextDoseTime);
      
      return (
        <Card title="Next Dose" className="mb-4">
          <div className="mt-2">
            <p className={`flex items-center text-2xl font-bold ${nextDoseInfo.overdue ? 'text-red-500' : 'text-blue-500'}`}>
              {nextDoseInfo.overdue ? 
                <Icon type="AlertTriangle" className="mr-2 text-red-500" /> : 
                <Icon type="Clock" className="mr-2" />
              }
              {dayOfWeek}, {timeOfDay} {timeZone}
            </p>
            <div className="mt-2 text-gray-700">
              {nextDoseInfo.overdue 
                ? nextDoseInfo.missedIntervals > 0 
                  ? <><span className="text-red-500"><strong>Overdue</strong></span> by <strong>{nextDoseInfo.time}</strong> (<strong>{nextDoseInfo.missedIntervals + 1}</strong> doses behind)</>
                  : <><span className="text-red-500"><strong>Overdue</strong></span> by <strong>{nextDoseInfo.time}</strong></>
                : <>Due in <strong>{nextDoseInfo.time}</strong></>
              }
            </div>
          </div>
        </Card>
      );
    };

    // Component for Adherence information
    const AdherenceCard = () => {
      const { 
        doses, 
        nextDoseTime, 
        currentTime, 
        calculateAdherence, 
        calculateStreak 
      } = useMedication();
      
      if (!(doses.length > 1 || (doses.length > 0 && nextDoseTime && currentTime > nextDoseTime))) {
        return null;
      }
      
      const adherence = calculateAdherence();
      const currentStreak = calculateStreak();
      
      return (
        <Card 
          title="Adherence" 
          className="mb-4"
          action={
            <div className="flex items-center">
              <span className={`text-lg font-bold ${currentStreak > 0 ? 'text-green-600' : 'text-gray-600'}`}>
                {currentStreak > 0 && '🔥 '}{currentStreak}
              </span>
            </div>
          }
        >
          <div className="w-full bg-gray-200 rounded-full h-4">
            <div 
              className={`h-4 rounded-full ${ADHERENCE_COLORS[adherence.status]}`}
              style={{ width: `${adherence.percentage}%` }}
            ></div>
          </div>
          <div className="flex justify-between mt-1">
            <span className="text-sm text-gray-500">0%</span>
            <span className="text-sm font-medium">{adherence.percentage}%</span>
            <span className="text-sm text-gray-500">100%</span>
          </div>
          <div className="mt-3">
            <p className="text-sm text-gray-600">
              Average deviation: {Math.round(adherence.avgDeviation * 10) / 10} minutes
            </p>
          </div>
          {currentStreak > 0 && (
            <div className="mt-2 p-2 bg-green-50 rounded-md border border-green-100">
              <p className="text-sm text-green-700 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                </svg>
                {currentStreak === 1 
                  ? "1 dose taken on time!" 
                  : `${currentStreak} consecutive doses taken on time!`}
              </p>
            </div>
          )}
        </Card>
      );
    };

    // Component for Dose History
    const DoseHistory = () => {
      const { 
        doses, 
        setShowDeleteConfirm, 
        setDeletingDose, 
        setShowEditModal, 
        setEditingDose, 
        setShowResetConfirm, 
        getDoseAdherence, 
        dateUtils 
      } = useMedication();
      
      return (!!doses.length &&
        <Card 
          title="History" 
          action={doses.length > 0 && (
            <button 
              onClick={() => setShowResetConfirm(true)} 
              className="text-red-500 text-sm hover:text-red-700"
            >
              <Icon type="Delete" size={16} />
            </button>
          )}
        >
            <ul className="mt-2 divide-y divide-gray-100">
              {[...doses].reverse().map((dose, index) => {
                const reversedIndex = doses.length - 1 - index;
                const isFirstDose = reversedIndex === 0;
                const adherenceInfo = !isFirstDose ? getDoseAdherence(dose.time, reversedIndex) : null;
                
                return (
                  <li key={dose.id} className="py-2 flex items-start">
                    <div className="flex-grow">
                      <div className="flex items-center">
                        <p className="text-gray-700">{dateUtils.formatDateTime(dose.time)}</p>
                        <button 
                          onClick={() => {
                            setEditingDose(dose);
                            setShowEditModal(true);
                          }}
                          className="text-blue-500 hover:text-blue-700 ml-2"
                        >
                          <Icon type="Edit" size={16} />
                        </button>
                      </div>
                      {!isFirstDose && (
                        <div className="mt-1">
                          <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${ADHERENCE_BG_COLORS[adherenceInfo.category]} ${ADHERENCE_TEXT_COLORS[adherenceInfo.category]}`}>
                            {adherenceInfo.exceedsCap ? '> 999' : adherenceInfo.adherencePercentage}% 
                            {' '}{adherenceInfo.isEarly ? 'early' : 'late'}
                          </span>
                        </div>
                      )}
                    </div>
                    <button 
                      onClick={() => {
                        setDeletingDose(dose);
                        setShowDeleteConfirm(true);
                      }}
                      className="text-red-500 hover:text-red-700 ml-4 mt-1"
                    >
                      <Icon type="Delete" size={16} />
                    </button>
                  </li>
                );
              })}
            </ul>
        </Card>
      );
    };

    /**
     * =================================================================
     * MAIN APPLICATION COMPONENTS
     * =================================================================
     */

    // Main Medication Tracker component
    const MedicationTracker = () => {
      const { 
        setShowAddModal 
      } = useMedication();
      const fullYearCreated = 2025;
      
      return (
        <div className="max-w-md mx-auto p-4 bg-gray-50 rounded-lg shadow-md">
          <h1 className="text-2xl font-bold mb-4 text-center">Medication Tracker</h1>
          
          <FrequencySelector />
          <NextDoseCard />
          
          <div className="mb-4">
            <button 
              onClick={() => setShowAddModal(true)} 
              className="w-full bg-blue-500 text-white py-3 px-4 rounded-lg font-medium hover:bg-blue-600 transition-colors flex items-center justify-center"
            >
              Record Dose
            </button>
          </div>
          
          <AdherenceCard />
          <DoseHistory />

          <p className="text-xs text-gray-600 mt-3">
              &copy; {fullYearCreated}{new Date().getFullYear() > fullYearCreated ? "–" + new Date().getFullYear() : ''} {window.location.host + window.location.pathname}
          </p>

          <AddDoseModal />
          <EditDoseModal />
          <ResetConfirmModal />
          <DeleteDoseConfirmModal />
        </div>
      );
    };

    // Main App component
    const App = () => (
      <div className="min-h-screen bg-gray-100 sm:py-8">
        <MedicationProvider>
          <MedicationTracker />
        </MedicationProvider>
      </div>
    );

    // Render the app
    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>